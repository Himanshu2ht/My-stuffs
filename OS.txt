Q2.

i.


#include <iostream>
#include <unistd.h>
#include <sys/types.h>

int main() {
    std::cout << "My Process ID (PID) is: " << getpid() << std::endl;
    std::cout << "My Parent's PID (PPID) is: " << getppid() << std::endl;
    return 0;
}




#include <iostream>
#include <unistd.h>
#include <sys/types.h>

int main() {
    pid_t pid = fork();

    if (pid < 0) {
        // pid < 0 means fork failed
        perror("Fork failed");
        return 1;
    } else if (pid == 0) {
        // pid == 0 means this is the CHILD process
        std::cout << "CHILD: My PID is " << getpid() 
                  << " and my parent is " << getppid() << std::endl;
    } else {
        // pid > 0 means this is the PARENT process, and pid is the Child's PID
        std::cout << "PARENT: My PID is " << getpid() 
                  << " and I created child PID " << pid << std::endl;
    }

    return 0;
}





#include <iostream>
#include <unistd.h>
#include <sys/types.h>
#include <signal.h>

int main() {
    pid_t pid = fork();

    if (pid == 0) {
        // Child Process: Do work indefinitely
        std::cout << "CHILD: Running (PID " << getpid() << ")..." << std::endl;
        sleep(5); // Sleep for 5 seconds
        std::cout << "CHILD: Finished normally." << std::endl;
    } else if (pid > 0) {
        // Parent Process: Wait a moment, then kill the child
        std::cout << "PARENT: Waiting 2 seconds then killing child " << pid << std::endl;
        sleep(2);
        
        // Send SIGKILL (Signal 9) to the child process
        if (kill(pid, SIGKILL) == 0) {
            std::cout << "PARENT: Successfully killed child " << pid << std::endl;
        } else {
            perror("Kill failed");
        }
    }
    return 0;
}






#include <iostream>
#include <unistd.h>
#include <sys/types.h>
#include <string.h>

int main() {
    int pipe_fd[2]; // pipe_fd[0] for READ, pipe_fd[1] for WRITE
    
    // Create the pipe
    if (pipe(pipe_fd) == -1) {
        perror("Pipe creation failed");
        return 1;
    }

    pid_t pid = fork();

    if (pid == 0) {
        // CHILD Process (Reader)
        close(pipe_fd[1]); // Close unused write end
        char buffer[100];
        
        // Read data from the pipe
        ssize_t bytes = read(pipe_fd[0], buffer, sizeof(buffer) - 1);
        buffer[bytes] = '\0'; // Null-terminate the string
        
        std::cout << "CHILD received: " << buffer << std::endl;
        close(pipe_fd[0]);
    } else if (pid > 0) {
        // PARENT Process (Writer)
        close(pipe_fd[0]); // Close unused read end
        const char *message = "Hello from the parent process!";
        
        // Write data to the pipe
        write(pipe_fd[1], message, strlen(message));
        
        std::cout << "PARENT sent message." << std::endl;
        close(pipe_fd[1]);
        wait(NULL); // Wait for the child to finish
    }
    return 0;
}










Q3

i.


#include <iostream>
#include <unistd.h>
#include <sys/types.h>

int main() {
    pid_t pid = fork();

    if (pid < 0) {
        perror("Fork failed");
        return 1;
    }

    // Both processes execute this code
    std::cout << "Hello from a process. My PID is: " << getpid()
              << " and fork() returned: " << pid << std::endl;

    return 0;
}




ii.

#include <iostream>
#include <unistd.h>
#include <sys/types.h>

int main() {
    pid_t pid = fork();

    if (pid < 0) {
        perror("Fork failed");
        return 1;
    } else if (pid == 0) {
        // Child process code
        std::cout << "Child process (PID: " << getpid()
                  << ") is running a different task." << std::endl;
    } else {
        // Parent process code (pid > 0)
        std::cout << "Parent process (PID: " << getpid()
                  << ") is running its main routine." << std::endl;
        std::cout << "Parent created child with PID: " << pid << std::endl;
    }

    return 0;
}





iii.

#include <iostream>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main() {
    pid_t pid = fork();

    if (pid < 0) {
        perror("Fork failed");
        return 1;
    } else if (pid == 0) {
        // Child process code
        std::cout << "Child process (PID: " << getpid() << ") is starting." << std::endl;
        sleep(2); // Simulate child doing some work for 2 seconds
        std::cout << "Child process (PID: " << getpid() << ") is finished." << std::endl;
    } else {
        // Parent process code
        std::cout << "Parent process (PID: " << getpid() << ") is waiting for child (PID: " << pid << ")." << std::endl;
        wait(NULL); // Parent waits here until child terminates
        std::cout << "Parent process detected child termination and is now exiting." << std::endl;
    }

    return 0;
}




4.


#include <iostream>
#include <fstream>
#include <string>
#include <cstdio>

void print_file_content(const char* filename, const char* title) {
    std::cout << "--- " << title << " ---" << std::endl;

    // Use C-style file handling for simplicity
    FILE* file = fopen(filename, "r");

    if (file == NULL) {
        perror("Error opening file");
        std::cout << "Could not open " << filename << std::endl;
        return;
    }

    char buffer[256];
    while (fgets(buffer, sizeof(buffer), file) != NULL) {
        std::cout << buffer;
    }

    fclose(file);
    std::cout << "-----------------------------------" << std::endl;
}

int main() {
    // 1. Kernel Version
    print_file_content("/proc/version", "Linux Kernel Version");

    // 2. CPU Information
    print_file_content("/proc/cpuinfo", "CPU Information");

    return 0;
}








5.

#include <iostream>
#include <fstream>
#include <string>
#include <iomanip>

int main() {
    std::ifstream meminfo("/proc/meminfo");
    std::string line;

    if (!meminfo.is_open()) {
        std::cerr << "Error: Could not open /proc/meminfo" << std::endl;
        return 1;
    }

    std::cout << "--- Linux Memory Information ---" << std::endl;

    // Read lines until EOF
    while (std::getline(meminfo, line)) {
        // Check for the three required fields
        if (line.compare(0, 9, "MemTotal:") == 0 ||
            line.compare(0, 8, "MemFree:") == 0 ||
            line.compare(0, 12, "MemAvailable:") == 0) {
            
            // Print the line as is
            std::cout << line << std::endl;
        }

        // Optimization: Stop after finding all relevant entries (optional, but cleaner)
        if (line.compare(0, 12, "MemAvailable:") == 0) {
            break; 
        }
    }

    std::cout << "--------------------------------" << std::endl;
    
    // Note: Used Memory is typically calculated as MemTotal - MemFree (or MemTotal - MemAvailable for a better measure).
    // The raw file doesn't provide a single "Used" field in this simplified way.
    
    return 0;
}






6.



#include <iostream>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

#define BUFFER_SIZE 4096

int main(int argc, char *argv[]) {
    if (argc != 3) {
        std::cerr << "Usage: " << argv[0] << " <source_file> <destination_file>" << std::endl;
        return 1;
    }

    const char *source_path = argv[1];
    const char *dest_path = argv[2];
    char buffer[BUFFER_SIZE];
    ssize_t bytes_read, bytes_written;

    // 1. Open source file for reading (O_RDONLY)
    int source_fd = open(source_path, O_RDONLY);
    if (source_fd < 0) {
        perror("Error opening source file");
        return 1;
    }

    // 2. Open/Create destination file for writing (O_WRONLY | O_CREAT | O_TRUNC)
    // Permission set to 0644 (Read/Write for owner, Read for group/others)
    int dest_fd = open(dest_path, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (dest_fd < 0) {
        perror("Error opening destination file");
        close(source_fd);
        return 1;
    }

    // 3. Read from source and write to destination in a loop
    while ((bytes_read = read(source_fd, buffer, BUFFER_SIZE)) > 0) {
        bytes_written = write(dest_fd, buffer, bytes_read);
        
        if (bytes_written != bytes_read) {
            perror("Error writing to destination file");
            close(source_fd);
            close(dest_fd);
            return 1;
        }
    }

    // Check if the loop terminated due to a read error
    if (bytes_read < 0) {
        perror("Error reading from source file");
        close(source_fd);
        close(dest_fd);
        return 1;
    }

    // 4. Close both file descriptors
    close(source_fd);
    close(dest_fd);

    std::cout << "File copied successfully." << std::endl;
    return 0;
}








7.


#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>

struct Process {
    int pid;
    int arrival_time;
    int burst_time;
    int waiting_time;
    int turnaround_time;
    int completion_time;
};

// Custom comparison function for FCFS: sort based on arrival time
bool compareArrivalTime(const Process& a, const Process& b) {
    // If arrival times are equal, use PID to ensure deterministic sorting
    if (a.arrival_time == b.arrival_time) {
        return a.pid < b.pid; 
    }
    return a.arrival_time < b.arrival_time;
}

void calculate_times(std::vector<Process>& processes) {
    int n = processes.size();
    
    // Sort the processes by arrival time (FCFS)
    std::sort(processes.begin(), processes.end(), compareArrivalTime);
    
    int current_time = 0;
    
    // Calculate waiting and turnaround times
    for (int i = 0; i < n; ++i) {
        // If the CPU is idle when the process arrives, start time is its arrival time
        if (current_time < processes[i].arrival_time) {
            current_time = processes[i].arrival_time;
        }
        
        // Completion Time (CT) = Start Time + Burst Time
        processes[i].completion_time = current_time + processes[i].burst_time;
        
        // Turnaround Time (TAT) = Completion Time - Arrival Time
        processes[i].turnaround_time = processes[i].completion_time - processes[i].arrival_time;
        
        // Waiting Time (WT) = Turnaround Time - Burst Time
        processes[i].waiting_time = processes[i].turnaround_time - processes[i].burst_time;
        
        // Update current time for the next process
        current_time = processes[i].completion_time;
    }
}

void print_results(const std::vector<Process>& processes) {
    int n = processes.size();
    double total_wt = 0;
    double total_tat = 0;

    std::cout << "\n--- FCFS Scheduling Results (Q7) ---" << std::endl;
    std::cout << left << setw(5) << "PID"
              << setw(10) << "Arrival"
              << setw(10) << "Burst"
              << setw(15) << "Completion"
              << setw(15) << "Waiting Time"
              << setw(15) << "Turnaround Time" << endl;
    
    for (const auto& p : processes) {
        std::cout << left << setw(5) << p.pid
                  << setw(10) << p.arrival_time
                  << setw(10) << p.burst_time
                  << setw(15) << p.completion_time
                  << setw(15) << p.waiting_time
                  << setw(15) << p.turnaround_time << endl;
        total_wt += p.waiting_time;
        total_tat += p.turnaround_time;
    }

    std::cout << "\nAverage Waiting Time: " << fixed << setprecision(2) << total_wt / n << endl;
    std::cout << "Average Turnaround Time: " << fixed << setprecision(2) << total_tat / n << endl;
    std::cout << "--------------------------------------\n" << endl;
}

int main() {
    // Define processes: (PID, Arrival Time, Burst Time)
    std::vector<Process> processes = {
        {1, 0, 6}, 
        {2, 1, 8},
        {3, 2, 7},
        {4, 3, 3}
    };
    
    calculate_times(processes);
    print_results(processes);

    return 0;
}













8.


#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>

struct Process {
    int pid;
    int burst_time;
    int arrival_time;
    int waiting_time;
    int turnaround_time;
};

// Custom comparison function for sorting based on burst time
bool compareBurstTime(const Process& a, const Process& b) {
    return a.burst_time < b.burst_time;
}

void calculate_times(std::vector<Process>& processes) {
    int n = processes.size();
    
    // Sort the processes by burst time (SJF)
    std::sort(processes.begin(), processes.end(), compareBurstTime);
    
    int current_time = 0;
    
    // Calculate waiting and turnaround times
    for (int i = 0; i < n; ++i) {
        // Waiting Time (WT) = Time when execution starts - Arrival Time
        // Since we assume Arrival Time = 0 and jobs are sorted, WT is simply the time elapsed
        processes[i].waiting_time = current_time - processes[i].arrival_time;
        
        // Turnaround Time (TAT) = Waiting Time + Burst Time
        processes[i].turnaround_time = processes[i].waiting_time + processes[i].burst_time;
        
        // Update current time for the next process
        current_time += processes[i].burst_time;
    }
}

void print_results(const std::vector<Process>& processes) {
    int n = processes.size();
    double total_wt = 0;
    double total_tat = 0;

    std::cout << "\n--- SJF Non-Preemptive Scheduling Results ---" << std::endl;
    std::cout << std::left << std::setw(5) << "PID"
              << std::setw(15) << "Burst Time"
              << std::setw(15) << "Waiting Time"
              << std::setw(15) << "Turnaround Time" << std::endl;
    
    for (const auto& p : processes) {
        std::cout << std::left << std::setw(5) << p.pid
                  << std::setw(15) << p.burst_time
                  << std::setw(15) << p.waiting_time
                  << std::setw(15) << p.turnaround_time << std::endl;
        total_wt += p.waiting_time;
        total_tat += p.turnaround_time;
    }

    std::cout << "\nAverage Waiting Time: " << std::fixed << std::setprecision(2) << total_wt / n << std::endl;
    std::cout << "Average Turnaround Time: " << std::fixed << std::setprecision(2) << total_tat / n << std::endl;
    std::cout << "-------------------------------------------\n" << std::endl;
}

int main() {
    // Define initial processes (assuming all arrive at time 0 for simple SJF)
    std::vector<Process> processes = {
        {1, 6, 0}, // PID 1, Burst 6, Arrival 0
        {2, 8, 0},
        {3, 7, 0},
        {4, 3, 0}
    };
    
    calculate_times(processes);
    print_results(processes);

    return 0;
}






9.


#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>

struct Process {
    int pid;
    int burst_time;
    int arrival_time;
    int priority; 
    int waiting_time;
    int turnaround_time;
};

// Custom comparison function for sorting based on priority (lower number = higher priority)
bool comparePriority(const Process& a, const Process& b) {
    return a.priority < b.priority;
}

void calculate_times(std::vector<Process>& processes) {
    int n = processes.size();
    
    // Sort the processes by priority
    std::sort(processes.begin(), processes.end(), comparePriority);
    
    int current_time = 0;
    
    // Calculate waiting and turnaround times
    for (int i = 0; i < n; ++i) {
        // Waiting Time (WT) = Time when execution starts - Arrival Time
        // Assuming Arrival Time = 0 for all for this basic non-preemptive example.
        processes[i].waiting_time = current_time - processes[i].arrival_time;
        
        // Turnaround Time (TAT) = Waiting Time + Burst Time
        processes[i].turnaround_time = processes[i].waiting_time + processes[i].burst_time;
        
        // Update current time for the next process
        current_time += processes[i].burst_time;
    }
}

void print_results(const std::vector<Process>& processes) {
    int n = processes.size();
    double total_wt = 0;
    double total_tat = 0;

    std::cout << "\n--- Non-Preemptive Priority Scheduling Results ---" << std::endl;
    std::cout << std::left << std::setw(5) << "PID"
              << std::setw(15) << "Burst Time"
              << std::setw(10) << "Priority"
              << std::setw(15) << "Waiting Time"
              << std::setw(15) << "Turnaround Time" << std::endl;
    
    for (const auto& p : processes) {
        std::cout << std::left << std::setw(5) << p.pid
                  << std::setw(15) << p.burst_time
                  << std::setw(10) << p.priority
                  << std::setw(15) << p.waiting_time
                  << std::setw(15) << p.turnaround_time << std::endl;
        total_wt += p.waiting_time;
        total_tat += p.turnaround_time;
    }

    std::cout << "\nAverage Waiting Time: " << std::fixed << std::setprecision(2) << total_wt / n << std::endl;
    std::cout << "Average Turnaround Time: " << std::fixed << std::setprecision(2) << total_tat / n << std::endl;
    std::cout << "--------------------------------------------------\n" << std::endl;
}

int main() {
    // Define initial processes: (PID, Burst Time, Arrival Time, Priority)
    // Priority: Lower number = Higher Priority
    std::vector<Process> processes = {
        {1, 10, 0, 3}, 
        {2, 5, 0, 1},  // Highest Priority
        {3, 8, 0, 4},
        {4, 2, 0, 2}
    };
    
    calculate_times(processes);
    print_results(processes);

    return 0;
}







10.



#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>

struct Process {
    int pid;
    int arrival_time;
    int burst_time;
    int remaining_time;
    int completion_time = 0;
    int start_time = -1;
    int waiting_time;
    int turnaround_time;
};

void calculate_srtf(std::vector<Process>& processes) {
    int n = processes.size();
    int completed = 0;
    int current_time = 0;
    int shortest_job_index = -1;
    int min_remaining_time = 99999;
    
    // Create a vector to track if a process has arrived
    std::vector<bool> is_completed(n, false);
    
    while (completed != n) {
        shortest_job_index = -1;
        min_remaining_time = 99999;

        // 1. Find the process with the minimum remaining time that has arrived
        for (int i = 0; i < n; ++i) {
            if (processes[i].arrival_time <= current_time && !is_completed[i]) {
                if (processes[i].remaining_time < min_remaining_time) {
                    min_remaining_time = processes[i].remaining_time;
                    shortest_job_index = i;
                }
            }
        }

        if (shortest_job_index == -1) {
            // No process ready to run, move time forward
            current_time++;
            continue;
        }

        // 2. Execute the shortest remaining job for 1 time unit
        int p_index = shortest_job_index;

        if (processes[p_index].start_time == -1) {
            processes[p_index].start_time = current_time;
        }

        processes[p_index].remaining_time--;
        current_time++;

        // 3. Check for completion
        if (processes[p_index].remaining_time == 0) {
            processes[p_index].completion_time = current_time;
            is_completed[p_index] = true;
            completed++;

            // Calculate metrics for the completed process
            processes[p_index].turnaround_time = processes[p_index].completion_time - processes[p_index].arrival_time;
            processes[p_index].waiting_time = processes[p_index].turnaround_time - processes[p_index].burst_time;
        }
    }
}

void print_results(const std::vector<Process>& processes) {
    int n = processes.size();
    double total_wt = 0;
    double total_tat = 0;

    std::cout << "\n--- SRTF Preemptive Scheduling Results ---" << std::endl;
    std::cout << std::left << std::setw(5) << "PID"
              << std::setw(10) << "Arrival"
              << std::setw(10) << "Burst"
              << std::setw(15) << "Completion"
              << std::setw(15) << "Waiting Time"
              << std::setw(15) << "Turnaround Time" << std::endl;
    
    for (const auto& p : processes) {
        std::cout << std::left << std::setw(5) << p.pid
                  << std::setw(10) << p.arrival_time
                  << std::setw(10) << p.burst_time
                  << std::setw(15) << p.completion_time
                  << std::setw(15) << p.waiting_time
                  << std::setw(15) << p.turnaround_time << std::endl;
        total_wt += p.waiting_time;
        total_tat += p.turnaround_time;
    }

    std::cout << "\nAverage Waiting Time: " << std::fixed << std::setprecision(2) << total_wt / n << std::endl;
    std::cout << "Average Turnaround Time: " << std::fixed << std::setprecision(2) << total_tat / n << std::endl;
    std::cout << "------------------------------------------\n" << std::endl;
}

int main() {
    // Define processes: (PID, Arrival Time, Burst Time)
    std::vector<Process> processes_data = {
        {1, 0, 8}, 
        {2, 1, 4},
        {3, 2, 9},
        {4, 3, 5}
    };
    
    // Initialize remaining time with burst time
    std::vector<Process> processes = processes_data;
    for (auto& p : processes) {
        p.remaining_time = p.burst_time;
        p.start_time = -1; // -1 indicates not started yet
    }
    
    calculate_srtf(processes);
    print_results(processes);

    return 0;
}








11.



#include <iostream>
#include <vector>
#include <pthread.h>
#include <numeric>

// Structure to pass data to each thread
struct ThreadData {
    const std::vector<int>* array_ptr;
    int start_index;
    int end_index;
    long long sublist_sum;
};

// The thread function: calculates the sum of its assigned sub-list
void* sum_sublist(void* arg) {
    ThreadData* data = static_cast<ThreadData*>(arg);
    long long current_sum = 0;
    
    // Iterate and sum the elements in the assigned range
    for (int i = data->start_index; i <= data->end_index; ++i) {
        current_sum += (*data->array_ptr)[i];
    }
    
    // Store the result back into the structure
    data->sublist_sum = current_sum;
    
    // Exit the thread
    pthread_exit(NULL);
}

int main() {
    // 1. Define the data array (n numbers, must be an even number for equal split)
    std::vector<int> numbers(1000); 
    // Fill the array with values 1, 2, 3, ... 1000
    std::iota(numbers.begin(), numbers.end(), 1); 
    int n = numbers.size();

    // Check if n is even for equal split
    if (n % 2 != 0) {
        std::cerr << "Error: List size must be even for equal division." << std::endl;
        return 1;
    }

    int mid = n / 2;
    pthread_t thread1, thread2;
    
    // 2. Prepare data for Thread 1 (first half)
    ThreadData data1;
    data1.array_ptr = &numbers;
    data1.start_index = 0;
    data1.end_index = mid - 1;

    // 3. Prepare data for Thread 2 (second half)
    ThreadData data2;
    data2.array_ptr = &numbers;
    data2.start_index = mid;
    data2.end_index = n - 1;

    // 4. Create threads
    int rc1 = pthread_create(&thread1, NULL, sum_sublist, &data1);
    int rc2 = pthread_create(&thread2, NULL, sum_sublist, &data2);
    
    if (rc1 || rc2) {
        std::cerr << "Error creating threads." << std::endl;
        return 1;
    }

    // 5. Wait for threads to complete (Join)
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    // 6. Combine results
    long long total_sum = data1.sublist_sum + data2.sublist_sum;

    std::cout << "--- PThread Summation Results ---" << std::endl;
    std::cout << "Sub-list 1 Sum: " << data1.sublist_sum << std::endl;
    std::cout << "Sub-list 2 Sum: " << data2.sublist_sum << std::endl;
    std::cout << "Total Sum of " << n << " numbers: " << total_sum << std::endl;
    std::cout << "-----------------------------------" << std::endl;
    
    return 0;
}





12.


#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>

using namespace std;

// Function to reset memory blocks before each allocation test
vector<int> reset_memory_blocks(const vector<int>& initial_blocks) {
    return initial_blocks;
}

// --- 1. FIRST-FIT Strategy ---
void first_fit(const vector<int>& initial_blocks, const vector<int>& processes) {
    vector<int> blocks = reset_memory_blocks(initial_blocks);
    int n_blocks = blocks.size();
    int n_processes = processes.size();
    vector<int> allocation(n_processes, -1); // Tracks which block is allocated to the process

    cout << "\n--- FIRST-FIT ALLOCATION ---" << endl;
    
    for (int i = 0; i < n_processes; ++i) {
        for (int j = 0; j < n_blocks; ++j) {
            // Find the FIRST block large enough
            if (blocks[j] >= processes[i]) {
                allocation[i] = j;
                blocks[j] -= processes[i]; // Allocate and reduce block size
                break;
            }
        }
    }

    cout << left << setw(10) << "Process" << setw(10) << "Size" << setw(15) << "Block ID" << endl;
    for (int i = 0; i < n_processes; ++i) {
        cout << left << setw(10) << (i + 1)
             << setw(10) << processes[i]
             << setw(15) << (allocation[i] != -1 ? to_string(allocation[i] + 1) : "Not Allocated") << endl;
    }
}

// --- 2. BEST-FIT Strategy ---
void best_fit(const vector<int>& initial_blocks, const vector<int>& processes) {
    vector<int> blocks = reset_memory_blocks(initial_blocks);
    int n_blocks = blocks.size();
    int n_processes = processes.size();
    vector<int> allocation(n_processes, -1);

    cout << "\n--- BEST-FIT ALLOCATION ---" << endl;
    
    for (int i = 0; i < n_processes; ++i) {
        int best_fit_index = -1;
        int min_fragmentation = 99999; 

        for (int j = 0; j < n_blocks; ++j) {
            // Check if block is big enough
            if (blocks[j] >= processes[i]) {
                int fragmentation = blocks[j] - processes[i];
                // Check if this block creates the smallest internal fragmentation (Best-Fit)
                if (fragmentation < min_fragmentation) {
                    min_fragmentation = fragmentation;
                    best_fit_index = j;
                }
            }
        }

        if (best_fit_index != -1) {
            allocation[i] = best_fit_index;
            blocks[best_fit_index] -= processes[i]; // Allocate and reduce block size
        }
    }

    cout << left << setw(10) << "Process" << setw(10) << "Size" << setw(15) << "Block ID" << endl;
    for (int i = 0; i < n_processes; ++i) {
        cout << left << setw(10) << (i + 1)
             << setw(10) << processes[i]
             << setw(15) << (allocation[i] != -1 ? to_string(allocation[i] + 1) : "Not Allocated") << endl;
    }
}

// --- 3. WORST-FIT Strategy ---
void worst_fit(const vector<int>& initial_blocks, const vector<int>& processes) {
    vector<int> blocks = reset_memory_blocks(initial_blocks);
    int n_blocks = blocks.size();
    int n_processes = processes.size();
    vector<int> allocation(n_processes, -1);

    cout << "\n--- WORST-FIT ALLOCATION ---" << endl;
    
    for (int i = 0; i < n_processes; ++i) {
        int worst_fit_index = -1;
        int max_fragmentation = -1; 

        for (int j = 0; j < n_blocks; ++j) {
            // Check if block is big enough
            if (blocks[j] >= processes[i]) {
                int fragmentation = blocks[j] - processes[i];
                // Check if this block creates the largest internal fragmentation (Worst-Fit)
                if (fragmentation > max_fragmentation) {
                    max_fragmentation = fragmentation;
                    worst_fit_index = j;
                }
            }
        }

        if (worst_fit_index != -1) {
            allocation[i] = worst_fit_index;
            blocks[worst_fit_index] -= processes[i]; // Allocate and reduce block size
        }
    }

    cout << left << setw(10) << "Process" << setw(10) << "Size" << setw(15) << "Block ID" << endl;
    for (int i = 0; i < n_processes; ++i) {
        cout << left << setw(10) << (i + 1)
             << setw(10) << processes[i]
             << setw(15) << (allocation[i] != -1 ? to_string(allocation[i] + 1) : "Not Allocated") << endl;
    }
}


int main() {
    // Memory blocks available (in KB)
    const vector<int> initial_blocks = {100, 500, 200, 300, 600};
    // Processes needing memory (in KB)
    const vector<int> processes = {212, 417, 112, 426};

    cout << "Initial Memory Blocks: [";
    for (size_t i = 0; i < initial_blocks.size(); ++i) {
        cout << initial_blocks[i] << (i < initial_blocks.size() - 1 ? ", " : "");
    }
    cout << "]" << endl;

    first_fit(initial_blocks, processes);
    
    best_fit(initial_blocks, processes);
    
    worst_fit(initial_blocks, processes);

    return 0;
}
